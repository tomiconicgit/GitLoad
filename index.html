<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GLB Attachment Tool</title>
    <link rel="manifest" href="data:application/manifest+json,{
        &quot;name&quot;: &quot;GLB Attachment Tool&quot;,
        &quot;short_name&quot;: &quot;GLB Attach&quot;,
        &quot;start_url&quot;: &quot;.&quot;,
        &quot;display&quot;: &quot;standalone&quot;,
        &quot;background_color&quot;: &quot;#d0d0d0&quot;,
        &quot;theme_color&quot;: &quot;#3a79cc&quot;,
        &quot;description&quot;: &quot;A tool to attach and transform GLB assets on a character rig.&quot;,
        &quot;icons&quot;: [{
            &quot;src&quot;: &quot;data:image/png;base64,iVBORw0KGgoAAAANSUEUgAAAMAAAADACAYAAABS3GwHAAAAaklEQVR4nO3BMQEAAADCoPVPbQ0PoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeDc1wAAGaT44gAAAAAElFTkSuQmCC&quot;,
            &quot;sizes&quot;: &quot;192x192&quot;,
            &quot;type&quot;: &quot;image/png&quot;
        }]
    }">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="GLB Attach">
    <style>
        :root {
            --primary-color: #3a79cc;
            --background-color: #f0f0f0;
            --ui-background: rgba(255, 255, 255, 0.85);
            --text-color: #333;
            --border-color: #ccc;
            --ui-height: 45vh; /* ✨ NEW: Control the UI panel height */
        }
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            display: flex;
            flex-direction: column;
        }
        #canvas-container {
            flex-grow: 1;
            min-height: 0;
            width: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-container {
            flex-shrink: 0;
            width: 100%;
            height: var(--ui-height); /* ✨ NEW: Fixed height for the UI */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            background: var(--ui-background);
            border-top: 1px solid var(--border-color);
            display: flex; /* ✨ NEW: Use flexbox to lay out UI sections */
            flex-direction: column;
        }
        .top-bar {
            display: grid; /* ✨ CHANGED: Use grid for better wrapping on small screens */
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            padding: 10px;
            gap: 10px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .btn { padding: 10px; border-radius: 8px; border: none; background: var(--primary-color); color: white; font-size: 14px; font-weight: bold; cursor: pointer; text-align: center; }
        .btn.secondary { background: #6c757d; }
        .btn.tertiary { background: #5a3acc; }
        .btn:active { opacity: 0.8; }
        input[type="file"] { display: none; }
        #tab-bar { display: flex; overflow-x: auto; padding: 5px; background: #e9e9e9; flex-shrink: 0; }
        .tab-btn { padding: 8px 16px; border: none; background: transparent; border-bottom: 2px solid transparent; cursor: pointer; font-size: 14px; flex-shrink: 0; }
        .tab-btn.active { font-weight: bold; color: var(--primary-color); border-bottom-color: var(--primary-color); }
        #control-panels { padding: 15px; overflow-y: auto; flex-grow: 1; } /* ✨ CHANGED: Fills remaining UI space */
        .panel { display: none; }
        .panel.active { display: block; }
        .control-group { margin-bottom: 15px; }
        .control-group h3 { margin: 0 0 10px; font-size: 16px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        .slider-container { display: grid; grid-template-columns: 20px 1fr 50px; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-container label { font-weight: bold; }
        .slider-container input[type=range] { width: 100%; }
        .slider-container input[type=number] { width: 50px; border: 1px solid var(--border-color); border-radius: 4px; padding: 2px; }
        .attachment-select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); }
        .material-item { margin-bottom: 8px; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="ui-container">
        <div class="top-bar">
            <button class="btn" id="loadCharacterBtn">Load Character</button>
            <button class="btn" id="loadAssetBtn">Load Asset</button>
            <button class="btn tertiary" id="loadAnimBtn">Load Animation</button> <button class="btn secondary" id="copyBtn">Copy Transform</button>
            <input type="file" id="characterInput" accept=".glb">
            <input type="file" id="assetInput" accept=".glb">
            <input type="file" id="animInput" accept=".glb"> </div>
        <div id="tab-bar"></div>
        <div id="control-panels"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Global State ---
        const clock = new THREE.Clock(); // ✨ NEW: For animation updates
        let mainCharacter = null;
        const sceneObjects = new Map();
        let activeObjectId = null;

        // --- UI & Canvas Elements ---
        const canvasContainer = document.getElementById('canvas-container');
        const controlPanelsContainer = document.getElementById('control-panels');
        const tabBarContainer = document.getElementById('tab-bar');
        const copyBtn = document.getElementById('copyBtn');

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.fog = new THREE.Fog(0xf0f0f0, 10, 50);

        const camera = new THREE.PerspectiveCamera(50, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        canvasContainer.appendChild(renderer.domElement);

        // --- Lighting & Floor ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(3, 10, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 4;
        dirLight.shadow.camera.bottom = -4;
        dirLight.shadow.camera.left = -4;
        dirLight.shadow.camera.right = 4;
        scene.add(dirLight);
        const floor = new THREE.Mesh( new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x999999, depthWrite: false }) );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2;

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); // ✨ NEW
            if (mainCharacter && mainCharacter.mixer) {
                mainCharacter.mixer.update(delta); // ✨ NEW: Update animation mixer
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // --- Window Resize ---
        function onWindowResize() {
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        window.addEventListener('resize', onWindowResize);
        
        // --- Core Loading Logic ---
        const gltfLoader = new GLTFLoader();

        function loadGLB(file, isCharacter) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                gltfLoader.parse(e.target.result, '', (gltf) => {
                    if (isCharacter) resetScene();
                    
                    const model = gltf.scene;
                    model.name = file.name.replace(/\.[^/.]+$/, "");
                    
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    
                    // ✨ CHANGED: New sizing logic
                    if (isCharacter) {
                        const scale = 1.65 / size.y; // Scale based on height to ~1.65m
                        model.scale.setScalar(scale);
                        box.setFromObject(model); // Recalculate bounds after scaling
                        model.position.y -= box.min.y; // Place feet on the floor
                    } else {
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 0.5 / maxDim; // Scale assets so largest dimension is ~0.5m
                        model.scale.setScalar(scale);
                        const center = box.getCenter(new THREE.Vector3());
                        model.position.sub(center); // Center asset at origin
                    }
                    
                    model.traverse(node => { if (node.isMesh) node.castShadow = true; });
                    
                    const objectData = {
                        mesh: model,
                        bones: [],
                        materials: new Map(),
                        mixer: null, // ✨ NEW
                        activeAction: null, // ✨ NEW
                    };

                    model.traverse(node => {
                        if (node.isBone) objectData.bones.push(node.name);
                        if (node.isMesh && node.material) {
                            if (!objectData.materials.has(node.material.uuid)) {
                                objectData.materials.set(node.material.uuid, {
                                    name: node.material.name || `Material_${objectData.materials.size}`,
                                    ref: node.material
                                });
                            }
                        }
                    });

                    sceneObjects.set(model.uuid, objectData);
                    scene.add(model);

                    if (isCharacter) mainCharacter = objectData;
                    
                    createUIForObject(objectData);
                    setActiveObject(model.uuid);
                });
            };
            reader.readAsArrayBuffer(file);
        }
        
        // ✨ NEW: Animation Loader
        function loadAnimation(file) {
            if (!file || !mainCharacter) {
                alert("Please load a character model first!");
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                gltfLoader.parse(e.target.result, '', (gltf) => {
                    const clip = gltf.animations[0];
                    if (!clip) {
                        alert("This GLB file contains no animations.");
                        return;
                    }

                    if (!mainCharacter.mixer) {
                        mainCharacter.mixer = new THREE.AnimationMixer(mainCharacter.mesh);
                    }

                    // Stop the previous animation
                    if (mainCharacter.activeAction) {
                        mainCharacter.activeAction.stop();
                    }

                    const action = mainCharacter.mixer.clipAction(clip);
                    action.setLoop(THREE.LoopRepeat, Infinity);
                    action.play();
                    mainCharacter.activeAction = action;
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function resetScene() {
            sceneObjects.forEach(data => scene.remove(data.mesh));
            sceneObjects.clear();
            mainCharacter = null;
            controlPanelsContainer.innerHTML = '';
            tabBarContainer.innerHTML = '';
        }

        // --- UI Generation & Event Handlers (Largely Unchanged) ---
        function createUIForObject(objectData) {
            const { mesh, bones, materials } = objectData;
            const id = mesh.uuid;
            
            const tab = document.createElement('button');
            tab.className = 'tab-btn';
            tab.textContent = mesh.name;
            tab.dataset.id = id;
            tab.onclick = () => setActiveObject(id);
            tabBarContainer.appendChild(tab);

            const panel = document.createElement('div');
            panel.className = 'panel';
            panel.dataset.id = id;
            
            let panelHTML = `
                <div class="control-group"><h3>Position</h3>
                    ${createSlider('pos-x', 'X', mesh.position.x, -5, 5, 0.01)}
                    ${createSlider('pos-y', 'Y', mesh.position.y, -5, 5, 0.01)}
                    ${createSlider('pos-z', 'Z', mesh.position.z, -5, 5, 0.01)}</div>
                <div class="control-group"><h3>Rotation (Degrees)</h3>
                    ${createSlider('rot-x', 'X', THREE.MathUtils.radToDeg(mesh.rotation.x), -180, 180, 1)}
                    ${createSlider('rot-y', 'Y', THREE.MathUtils.radToDeg(mesh.rotation.y), -180, 180, 1)}
                    ${createSlider('rot-z', 'Z', THREE.MathUtils.radToDeg(mesh.rotation.z), -180, 180, 1)}</div>
                <div class="control-group"><h3>Scale</h3>
                    ${createSlider('scale-all', 'S', mesh.scale.x, 0.1, 5, 0.01)}</div>`;
            
            if (mainCharacter && objectData !== mainCharacter) {
                const boneOptions = mainCharacter.bones.map(name => `<option value="${name}">${name}</option>`).join('');
                panelHTML += `<div class="control-group"><h3>Attachment</h3>
                    <select class="attachment-select" data-id="${id}">
                        <option value="scene">-- Detach (World) --</option>
                        ${boneOptions}</select></div>`;
            }

            if (materials.size > 0) {
                 panelHTML += `<div class="control-group"><h3>Materials</h3>`;
                 materials.forEach((mat, uuid) => {
                     panelHTML += `<div class="material-item"><span>${mat.name}</span>
                        <button class="btn secondary" style="float: right; padding: 5px 10px;" onclick="document.getElementById('texture-input-${uuid}').click()">Apply Texture</button>
                        <input type="file" id="texture-input-${uuid}" accept="image/*" style="display:none;" data-mat-uuid="${uuid}"></div>`;
                 });
                 panelHTML += `</div>`;
            }

            panel.innerHTML = panelHTML;
            controlPanelsContainer.appendChild(panel);
            addEventListenersToPanel(panel, objectData);
        }

        function createSlider(id, label, value, min, max, step) {
            return `<div class="slider-container">
                    <label for="${id}">${label}</label>
                    <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}">
                    <input type="number" id="${id}-num" min="${min}" max="${max}" step="${step}" value="${value}"></div>`;
        }

        function addEventListenersToPanel(panel, objectData) {
            const { mesh } = objectData;
            
            const updateTransform = () => {
                mesh.position.set(parseFloat(panel.querySelector('#pos-x').value), parseFloat(panel.querySelector('#pos-y').value), parseFloat(panel.querySelector('#pos-z').value));
                mesh.rotation.set(THREE.MathUtils.degToRad(parseFloat(panel.querySelector('#rot-x').value)), THREE.MathUtils.degToRad(parseFloat(panel.querySelector('#rot-y').value)), THREE.MathUtils.degToRad(parseFloat(panel.querySelector('#rot-z').value)));
                const scale = parseFloat(panel.querySelector('#scale-all').value);
                mesh.scale.set(scale, scale, scale);
            };

            ['pos-x', 'pos-y', 'pos-z', 'rot-x', 'rot-y', 'rot-z', 'scale-all'].forEach(axis => {
                const slider = panel.querySelector(`#${axis}`);
                const number = panel.querySelector(`#${axis}-num`);
                slider.addEventListener('input', () => { number.value = slider.value; updateTransform(); });
                number.addEventListener('input', () => { slider.value = number.value; updateTransform(); });
            });
            
            const attachmentSelect = panel.querySelector('.attachment-select');
            if (attachmentSelect) {
                attachmentSelect.addEventListener('change', (e) => {
                    const boneName = e.target.value;
                    if (boneName === 'scene') scene.attach(mesh);
                    else {
                        const bone = mainCharacter.mesh.getObjectByName(boneName);
                        if (bone) bone.attach(mesh);
                    }
                });
            }

            objectData.materials.forEach((mat, uuid) => {
                panel.querySelector(`#texture-input-${uuid}`).addEventListener('change', (e) => loadTextureForMaterial(e.target.files[0], mat.ref));
            });
        }
        
        function loadTextureForMaterial(file, material) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                new THREE.TextureLoader().load(e.target.result, (texture) => {
                    texture.flipY = false;
                    texture.colorSpace = THREE.SRGBColorSpace;
                    material.map = texture;
                    material.needsUpdate = true;
                });
            };
            reader.readAsDataURL(file);
        }

        function setActiveObject(id) {
            activeObjectId = id;
            document.querySelectorAll('.tab-btn, .panel').forEach(el => {
                el.classList.toggle('active', el.dataset.id === id);
            });
        }

        function copyTransform() {
            if (!activeObjectId || !sceneObjects.has(activeObjectId)) {
                alert("Select an asset to copy its transform."); return;
            }
            const { mesh } = sceneObjects.get(activeObjectId);
            if (!mesh.parent || !mesh.parent.isBone) {
                alert("Asset must be attached to a character bone to copy its local transform."); return;
            }
            const { position: pos, rotation: rot, scale: scl } = mesh;
            const output = `// Transform for ${mesh.name} attached to ${mesh.parent.name}\n` +
                           `object.position.set(${pos.x.toFixed(4)}, ${pos.y.toFixed(4)}, ${pos.z.toFixed(4)});\n` +
                           `object.rotation.set(${rot.x.toFixed(4)}, ${rot.y.toFixed(4)}, ${rot.z.toFixed(4)}); // Radians\n` +
                           `object.scale.set(${scl.x.toFixed(4)}, ${scl.y.toFixed(4)}, ${scl.z.toFixed(4)});`;
            navigator.clipboard.writeText(output).then(() => {
                copyBtn.textContent = 'Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy Transform', 1500);
            });
        }

        // --- Initial Event Listeners ---
        document.getElementById('loadCharacterBtn').onclick = () => document.getElementById('characterInput').click();
        document.getElementById('loadAssetBtn').onclick = () => {
            if (!mainCharacter) alert("Please load a character first!");
            else document.getElementById('assetInput').click();
        };
        document.getElementById('loadAnimBtn').onclick = () => document.getElementById('animInput').click(); // ✨ NEW
        document.getElementById('characterInput').onchange = (e) => loadGLB(e.target.files[0], true);
        document.getElementById('assetInput').onchange = (e) => loadGLB(e.target.files[0], false);
        document.getElementById('animInput').onchange = (e) => loadAnimation(e.target.files[0]); // ✨ NEW
        copyBtn.onclick = copyTransform;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#121212" media="(prefers-color-scheme: dark)">
    <title>My GitHub PWA</title>
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJzaG9ydF9uYW1lIjogIkdpdEh1YiBQV0EiLAogICJuYW1lIjogIk15IEdpdEh1YiBQV0EiLAogICJpY29ucyI6IFtdLAogICJzdGFydF91cmwiOiAiLmluZGV4Lmh0bWwiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiNmZmZmZmYiLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJ0aGVtZV9jb2xvciI6ICIjMDA3YmZmIgp9">
    <style>
        :root {
            --bg-color: #f4f4f4;
            --text-color: #333;
            --accent-color: #007bff;
            --input-bg: #fff;
            --status-bg: #e9ecef;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #ddd;
                --accent-color: #0d6efd;
                --input-bg: #333;
                --status-bg: #222;
            }
        }
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        input, select, button {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            box-sizing: border-box;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid #ccc;
        }
        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            opacity: 0.9;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--status-bg);
            border-radius: 5px;
            word-wrap: break-word;
        }
        #fileTree {
            list-style-type: none;
            padding: 0;
        }
        #fileTree li {
            cursor: pointer;
            margin: 5px 0;
        }
        #fileTree li.folder::before {
            content: 'üìÅ ';
        }
        #fileTree li.file::before {
            content: 'üìÑ ';
        }
        #fileContent {
            margin-top: 20px;
            white-space: pre-wrap;
            background-color: var(--input-bg);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        #progressBar {
            width: 100%;
            background-color: #ddd;
            height: 20px;
            margin-top: 10px;
            border-radius: 5px;
            overflow: hidden;
        }
        #progress {
            width: 0%;
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <h1>My GitHub PWA</h1>
    <p>A mobile-friendly PWA for managing GitHub repos. Supports dark mode, file browsing, editing, and large uploads up to 50MB with progress.</p>
    <p><strong>Troubleshooting Tip:</strong> Ensure your token has 'repo' scope (classic) or 'Contents: write' (fine-grained). For errors, check the detailed message below or console.</p>
    
    <label for="token">GitHub Token:</label>
    <input type="password" id="token" placeholder="Enter your GitHub token">
    <button id="saveToken">Save Token</button>
    
    <button id="fetchRepos">Load My Repositories</button>
    
    <label for="repoSelect">Select Repository:</label>
    <select id="repoSelect">
        <option value="">-- Select a repo --</option>
    </select>
    
    <div id="repoActions" style="display: none;">
        <h2>Files in Repo</h2>
        <ul id="fileTree"></ul>
        
        <h2>Upload File (up to 50MB)</h2>
        <input type="file" id="fileInput">
        <label for="uploadPath">Upload Path (optional, defaults to root/file name):</label>
        <input type="text" id="uploadPath" placeholder="e.g., folder/file.ext">
        <button id="uploadButton">Upload</button>
        <div id="progressBar" style="display: none;">
            <div id="progress"></div>
        </div>
    </div>
    
    <div id="fileActions" style="display: none;">
        <h2>File Actions</h2>
        <button id="viewFile">View</button>
        <button id="renameFile">Rename/Move</button>
        <button id="deleteFile">Delete</button>
        <div id="fileContent"></div>
    </div>
    
    <div id="status"></div>

    <script>
        // PWA Service Worker (basic caching)
        if ('serviceWorker' in navigator) {
            const swCode = `
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('github-pwa-v1').then((cache) => cache.addAll(['/']))
  );
});
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => response || fetch(event.request))
  );
});
            `;
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            navigator.serviceWorker.register(swUrl)
                .then(reg => console.log('SW registered'))
                .catch(err => console.log('SW error', err));
        }

        const tokenInput = document.getElementById('token');
        const saveTokenButton = document.getElementById('saveToken');
        const fetchReposButton = document.getElementById('fetchRepos');
        const repoSelect = document.getElementById('repoSelect');
        const fileTree = document.getElementById('fileTree');
        const fileInput = document.getElementById('fileInput');
        const uploadPathInput = document.getElementById('uploadPath');
        const uploadButton = document.getElementById('uploadButton');
        const progressBar = document.getElementById('progressBar');
        const progress = document.getElementById('progress');
        const viewFileButton = document.getElementById('viewFile');
        const renameFileButton = document.getElementById('renameFile');
        const deleteFileButton = document.getElementById('deleteFile');
        const fileContent = document.getElementById('fileContent');
        const statusDiv = document.getElementById('status');
        const repoActions = document.getElementById('repoActions');
        const fileActions = document.getElementById('fileActions');

        let token = localStorage.getItem('githubToken') || '';
        tokenInput.value = token;
        let selectedRepo = '';
        let selectedPath = '';
        let currentTree = {};
        let selectedSha = '';

        saveTokenButton.addEventListener('click', () => {
            token = tokenInput.value.trim();
            if (token) {
                localStorage.setItem('githubToken', token);
                statusDiv.textContent = 'Token saved.';
            } else {
                statusDiv.textContent = 'Please enter a token.';
            }
        });

        fetchReposButton.addEventListener('click', async () => {
            if (!token) return statusDiv.textContent = 'No token.';
            statusDiv.textContent = 'Fetching repos...';
            try {
                const response = await fetch('https://api.github.com/user/repos?per_page=100', {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Status: ${response.status}`);
                }
                const repos = await response.json();
                repoSelect.innerHTML = '<option value="">-- Select a repo --</option>';
                repos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = repo.full_name;
                    option.textContent = repo.full_name;
                    repoSelect.appendChild(option);
                });
                statusDiv.textContent = 'Repos loaded.';
            } catch (error) {
                statusDiv.textContent = `Error fetching repos: ${error.message}`;
                console.error(error);
            }
        });

        repoSelect.addEventListener('change', async () => {
            selectedRepo = repoSelect.value;
            if (!selectedRepo) return;
            repoActions.style.display = 'block';
            statusDiv.textContent = 'Loading files...';
            await loadTree('');
            statusDiv.textContent = 'Files loaded.';
        });

        async function loadTree(path) {
            try {
                const response = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(path)}`, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Status: ${response.status}`);
                }
                const contents = await response.json();
                fileTree.innerHTML = '';
                contents.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    li.className = item.type === 'dir' ? 'folder' : 'file';
                    li.dataset.path = item.path;
                    li.dataset.sha = item.sha;
                    if (item.type === 'dir') {
                        li.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            if (li.querySelector('ul')) return;
                            const subUl = document.createElement('ul');
                            li.appendChild(subUl);
                            await loadSubTree(subUl, item.path);
                        });
                    } else {
                        li.addEventListener('click', (e) => {
                            e.stopPropagation();
                            selectedPath = item.path;
                            selectedSha = item.sha;
                            fileActions.style.display = 'block';
                            statusDiv.textContent = `Selected: ${item.path}`;
                        });
                    }
                    fileTree.appendChild(li);
                });
            } catch (error) {
                statusDiv.textContent = `Error loading tree: ${error.message}`;
                console.error(error);
            }
        }

        async function loadSubTree(ul, path) {
            try {
                const response = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(path)}`, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Status: ${response.status}`);
                }
                const contents = await response.json();
                contents.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item.name;
                    li.className = item.type === 'dir' ? 'folder' : 'file';
                    li.dataset.path = item.path;
                    li.dataset.sha = item.sha;
                    if (item.type === 'dir') {
                        li.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            if (li.querySelector('ul')) return;
                            const subUl = document.createElement('ul');
                            li.appendChild(subUl);
                            await loadSubTree(subUl, item.path);
                        });
                    } else {
                        li.addEventListener('click', (e) => {
                            e.stopPropagation();
                            selectedPath = item.path;
                            selectedSha = item.sha;
                            fileActions.style.display = 'block';
                            statusDiv.textContent = `Selected: ${item.path}`;
                        });
                    }
                    ul.appendChild(li);
                });
            } catch (error) {
                statusDiv.textContent = `Error loading subtree: ${error.message}`;
                console.error(error);
            }
        }

        viewFileButton.addEventListener('click', async () => {
            if (!selectedPath) return;
            statusDiv.textContent = 'Fetching file...';
            try {
                const response = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(selectedPath)}`, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Status: ${response.status}`);
                }
                const data = await response.json();
                const content = atob(data.content.replace(/\n/g, ''));
                fileContent.textContent = content;
                statusDiv.textContent = 'File viewed.';
            } catch (error) {
                statusDiv.textContent = `Error viewing file: ${error.message}`;
                console.error(error);
                fileContent.innerHTML = `<a href="https://github.com/${selectedRepo}/blob/main/${encodeURIComponent(selectedPath)}" target="_blank">Download/View on GitHub</a>`;
            }
        });

        renameFileButton.addEventListener('click', async () => {
            if (!selectedPath) return;
            const newPath = prompt('Enter new path (for rename/move):', selectedPath);
            if (!newPath || newPath === selectedPath) return;
            statusDiv.textContent = 'Moving/renaming...';
            try {
                // Fetch old content
                const getResp = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(selectedPath)}`, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                });
                if (!getResp.ok) {
                    const errorData = await getResp.json();
                    throw new Error(errorData.message || `Get status: ${getResp.status}`);
                }
                const data = await getResp.json();
                
                // Upload to new path
                const putResp = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(newPath)}`, {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: `Rename ${selectedPath} to ${newPath}`, content: data.content })
                });
                if (!putResp.ok) {
                    const errorData = await putResp.json();
                    throw new Error(errorData.message || `Put status: ${putResp.status}`);
                }
                
                // Delete old
                const delResp = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(selectedPath)}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: `Delete ${selectedPath} after rename`, sha: selectedSha })
                });
                if (!delResp.ok) {
                    const errorData = await delResp.json();
                    throw new Error(errorData.message || `Delete status: ${delResp.status}`);
                }
                
                statusDiv.textContent = 'Renamed/moved successfully.';
                await loadTree('');
            } catch (error) {
                statusDiv.textContent = `Error renaming/moving: ${error.message}`;
                console.error(error);
            }
        });

        deleteFileButton.addEventListener('click', async () => {
            if (!selectedPath || !confirm('Delete this file?')) return;
            statusDiv.textContent = 'Deleting...';
            try {
                const response = await fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(selectedPath)}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: `Delete ${selectedPath}`, sha: selectedSha })
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Status: ${response.status}`);
                }
                statusDiv.textContent = 'Deleted successfully.';
                await loadTree('');
                fileActions.style.display = 'none';
            } catch (error) {
                statusDiv.textContent = `Error deleting: ${error.message}`;
                console.error(error);
            }
        });

        uploadButton.addEventListener('click', () => {
            const file = fileInput.files[0];
            if (!file || !selectedRepo) return statusDiv.textContent = 'Select file and repo.';
            if (file.size > 50 * 1024 * 1024) return statusDiv.textContent = 'File too large (max 50MB; GitHub limit is 100MB but base64 inflates size).';
            const path = uploadPathInput.value.trim() || file.name;
            statusDiv.textContent = 'Preparing...';
            progressBar.style.display = 'block';
            progress.style.width = '0%';

            const reader = new FileReader();
            reader.onprogress = (e) => {
                if (e.lengthComputable) progress.style.width = `${(e.loaded / e.total) * 50}%`; // 50% for reading
            };
            reader.onload = () => {
                const base64 = reader.result.split(',')[1];
                statusDiv.textContent = 'Uploading...';
                const xhr = new XMLHttpRequest();
                xhr.open('PUT', `https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(path)}`);
                xhr.setRequestHeader('Authorization', `token ${token}`);
                xhr.setRequestHeader('Accept', 'application/vnd.github.v3+json');
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) progress.style.width = `${50 + (e.loaded / e.total) * 50}%`; // 50-100% for upload
                };
                xhr.onload = () => {
                    progressBar.style.display = 'none';
                    if (xhr.status >= 200 && xhr.status < 300) {
                        statusDiv.textContent = 'Uploaded successfully! File pushed to repo.';
                        loadTree('');
                    } else {
                        let errorMsg = `HTTP ${xhr.status}: ${xhr.statusText}`;
                        try {
                            const errorData = JSON.parse(xhr.response);
                            errorMsg = `GitHub Error: ${errorData.message || errorMsg}` + (errorData.errors ? ` - ${errorData.errors.map(e => e.message).join(', ')}` : '');
                        } catch {}
                        statusDiv.textContent = errorMsg;
                        console.error('Upload error:', xhr.response);
                    }
                };
                xhr.onerror = () => {
                    statusDiv.textContent = 'Network error during upload. Check connection.';
                    progressBar.style.display = 'none';
                    console.error('XHR error');
                };

                // Check for existing SHA
                fetch(`https://api.github.com/repos/${selectedRepo}/contents/${encodeURIComponent(path)}`, {
                    headers: { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' }
                }).then(res => {
                    if (res.ok) return res.json();
                    if (res.status === 404) return { sha: undefined };
                    return res.json().then(errorData => { throw new Error(errorData.message || `Check status: ${res.status}`); });
                }).then(data => {
                    const body = {
                        message: `Upload ${path} via PWA`,
                        content: base64
                    };
                    if (data.sha) body.sha = data.sha;
                    xhr.send(JSON.stringify(body));
                }).catch(err => {
                    statusDiv.textContent = `Error checking file existence: ${err.message}`;
                    progressBar.style.display = 'none';
                    console.error(err);
                });
            };
            reader.onerror = () => {
                statusDiv.textContent = 'Error reading file.';
                progressBar.style.display = 'none';
            };
            reader.readAsDataURL(file);
        });
    </script>
</body>
</html>